# to do
- スクリプト周り(scripts/)をダウンロードして、このプロジェクト用に調整。特にPATHは変更する必要あるかも。
- Speckit の 残りのプロンプトの調整。 clarify は以下のようにしたい。
    推奨度と理由をつけて選択肢を提示します。（推奨度：⭐の5段階評価）。質問は最大3つまでとする。選択肢を提示するときは、常に考えられる選択肢を5～7個リストアップし、有力な2～4個に絞り込みます。
      - clarify の修正できたけど、このあとのPLANとかでPATHが変更になったら再度調整する部分が出てくるので注意。
      - なので、全体が調整できたあとに、再度スクリプト内のPATHを見直す
- 指示用プロンプトの調整
  - AGENTS.md, constitution.md も調整。TDD スタイル を維持しながら、このディレクトリ構造に合わせたい。さらに、全体アーキテクチャ → マイクロサービス という構造にしたいので、architecture/ の作成や全体アーキテクチャの ExecPlan の作成、マイクロサービスの Spec や ExecPlan を作るように指示したい。
- Jujutsu をアンイストールする。Jules が並列実装に対応したため。ローカルに Jules のメモあり。
  - Jules を使う場合は Issueドリブンになるのでローカルメモ管理方式ではない。Github Copilot も Issueドリブンの仕様になっているのでそれで良いかも。
- Speckit リポジトリのチェックリストが4つくらいあったので、それも取り入れたい。
- 各ステップをゲート制にするために、ゲートを合格しているか確認する用のスクリプトを用意する。合格なら次のステップに行けるようにする。
- 毎回このディレクトリ構造になるように、スクリプトを作ってそれを実行すれば、この構造になるなスクリプトを用意したい。


## 方針
結論から言うと、この speckit の性質と「長期間動くエージェント＋ブランチ運用」を考えると、仕様書 spec はフィーチャ単位で作るほうがエージェントはかなり扱いやすいです。
ただし「エピック単位の視点」は ExecPlan 側でちゃんと持つ、という役割分担にするとバランスが良いです。
/speckit.specify は「1 回のコマンド＝1 個の機能説明＝1 個のブランチ」という動きなので、
1 ブランチ ↔ 1 フィーチャ ↔ 1 spec.md ↔ 1 checklist
という対応にすると、エージェント側のメンタルモデルがシンプルになる。
長期間動くエージェントにとっては：
- 小さめの spec（1 フィーチャ分）だと、「毎回少しだけ進めて成果物を残す」単位が明確
- ブランチと spec が 1 対 1 なので、「今どの spec を編集すべきか」で迷わない
一方、エピック全体の見取り図や優先順位は、ExecPlan 側の Progress / Plan of Work / Context and Orientation でまとめて持てばよいので、
「エピックの視点」は ExecPlan に寄せ、仕様の細かさはフィーチャ側に寄せるという分担がきれいにハマる。

### メリット
speckit 側：
- 「どのフィーチャの spec / checklist を編集すべきか」を
- features[].spec_path / features[].checklist_path から機械的に決定可能。

ExecPlan 側：
- epics[].exec_plan_path だけ見れば「このエピック全体の計画書」に飛べる。
- ExecPlan 内から features の ID（F-XXX-YYY）を列挙して参照できる。

エージェント：
- 「今 F-USER-001 をやっている」＝
  - 見る spec: features[F-USER-001].spec_path
  - 直す checklist: features[F-USER-001].checklist_path
  - 所属するエピックの計画: epics[epic_id].exec_plan_path
というシンプルな 3 つの参照で済む。


## done
- PLANS.md の修正
- specify.md の修正(これでコマンドが使えるようになった)



---

# 長期稼働型 AI エージェント

このリポジトリは、**長期稼働するAIコーディングエージェントと人間が協働するため**に設計されています。

主要な概念は以下の通りです：
- 自明な作業以外のすべての作業は、**機能仕様書 (Feature Spec)** と **実行計画 (ExecPlan)** によって主導されます。わざわざ計画書を作るまでもない小規模な作業では作成しません。
- 仕様書 (Specs) は **機能単位 (per-feature)** です（小さな単位）。
- 実行計画 (ExecPlans) は **エピック単位 (per-epic)** です（より大きな作業単位）。
- 重要なことはすべてファイルに書き込まれるため、ステートレスなエージェントであっても常に途中から再開できます。

## コンセプト

- 人間エンジニアの習慣を“外部成果物”として強制する。
- 「ハーネス」というのは、エージェントの振る舞いを決める外側の仕組みのこと。
- Anthropic は、人間のエンジニアがふだん行っていること（タスク分解、チケット管理、コミットログ、テスト、進捗メモなど）を、「ファイルやスクリプトという形の成果物として必ず残させる」ようにした。このやり方をエージェントも真似できるようにした。

## 用語と関係性

- AI-Agent-progress.txt: 「時間軸のログ」（セッション横断で何がいつ起きたか）
  - いつ何が起きたかの高レベルな履歴 → AI-Agent-progress.txt を時系列に追えば分かる。ExecPlan の Progress 更新履歴など。
- ExecPlan: 「エピック単位の設計＋作業計画＋進捗＋決定」（そのエピックに閉じたストーリー）
  - 細かいストーリーと背景 → ExecPlan を読めば分かる。
- architecture/: 「システム全体の設計図」（静的なアーキテクチャの説明）
  - 「いま・あるいは目指すべきシステム構造」を、実装から少し距離をおいて説明する層。
- plans/system/: 「システム全体エピック用の ExecPlan」（アーキテクチャを“実現・変更するための計画書」）
  - architecture に書かれた方向性・設計を、実際のコードベースに落とし込むためのステップバイステップの計画。

| 視点  | AI-Agent-progress.txt                     | ExecPlan (`exec-plan.md`)            |
| --- | ----------------------------------------- | ------------------------------------ |
| 単位  | リポジトリ全体・全エピック横断                           | **1 エピックごと**（`EPIC-XXX-YYY` 単位）      |
| 中身  | 時系列のイベントログ（いつ・何が行われたかの一行メモ）               | 目的・文脈・作業計画・進捗・決定・振り返りを含む**長文ドキュメント** |
| 時間軸 | セッション横断・全期間                               | そのエピックのライフサイクル                       |
| 粒度  | 「○○を実行した」「spec check FAILED」など比較的ざくっとした記録 | どのファイルをどう編集し、どんなコマンドをどう実行するかまで詳細     |
| 使い道 | ハーネス視点の監査ログ・CI やエージェントの挙動トレース             | 実装者／エージェントが**このエピックを完遂するために読む“手順書”** |

```text
architecture/
  ├── system-architecture.md
  ├── service-boundaries.md
  ├── deployment-topology.md
  └── diagrams/
       ↑
       │（システムの「あるべき姿」「全体像」を説明）
       │
plans/system/
  └── EPIC-SYS-001-foundation/exec-plan.md
       ↑
       │（architecture を前提に、
       │  「このリポジトリで何をどう変えるか」を落とし込む）
       │
services/, tests/, scripts/
  （ExecPlan に従って、実際のコード・テスト・スクリプトが変更される）
```

## Onboarding

このリポジトリで具体的な作業を始めるときは、詳細な手順やディレクトリ構成、`/speckit.*` フローや `scripts/validate_spec.sh` の使い方をまとめた
* `docs/onboarding.md`
を最初に参照してください。

以降のセッションでは、README を毎回読み直す必要はなく、`docs/onboarding.md` と各 ExecPlan / spec を見れば十分です。