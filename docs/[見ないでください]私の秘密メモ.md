# ブランチ
- ブランチ： F-API-002-minirag-backend と F-API-003-minirag-chat-ui
  - 002がバックエンド、003がフロントエンドのブランチにした。フロントエンドは一旦、簡易HTMLのチャットUIにしているので後でアバターUIと統合する
  - メモリーム開発中
  - JulesはDockerが使えないのでかなり厳しいかも。一旦Codex CLIで実装してもらい、プルリクもマージした。
  http://127.0.0.1:9143/
  でチャットUIにアクセスできる。
↑
- ブランチ：dev-0101
  - F-API-001-sandbox の内容をコピーして新しいブランチ dev-0101 を作成
  - これが最新。ここから開発開始する
↑
- ブランチ：F-API-001-sandbox
  - 修正中に勝手に作られちゃった。
↑
- ブランチ：Skills
  - Spec に Skill 要素を追加

# to do
- そろそろ一回メモリームかS&P500効率的フロンティアかDeepResearch(動的に計画を修正する版「これで AutoResearch を定量的に評価してみたい。さらに失敗パターンを踏まえたサービス設計も書いた。」)でテストしてみる。LLMは「https://openrouter.ai/deepseek/deepseek-v3.2-speciale」で良さそう。Speckit と同じフローで動かせば良いと思っていたけど、最初にハーネスにFeatureを登録してIDを持たせたうえで--feature-idを付けて実行する必要があるっぽい。つまり、feature_list.json を最初に作る必要があるみたい。なので、feature_list.json を作る工程 `bootstrap-features.md + create-new-feature.sh` を /speckit.specify --feature-id F-XXX-YYY ... の前に入れた。bootstrap-features.md を使うと feature-id が複数出てくるのでそれを使って、「/speckit.specify --feature-id F-XXX-YYY 仕様説明 」する
  - と思ったけど、このやり方はできないと思ったので specify.md を修正した。結果、従来の Speckit と同様に /speckit.specify "仕様説明"  → (複数の Feature ID と各 spec.md とチェックリスト が生成される) → /speckit.clarify → /speckit.plan で OK
- いくつかは空の受け皿がある状態になっている
- スクリプト周り(scripts/)をダウンロードして、このプロジェクト用に調整。特にPATHは変更する必要あるかも。
  - 【done】common.sh
  - 【done】create-new-feature.sh
  - 【修正不要だった】setup-plan.sh
  - 【不要】update-claude-md.sh
- 以下もPATHなどの調整が必要かも
  - 【done】plan-template.md
  - 【done】spec-template.md
  - 【done】tasks-template.md
- 【done】Speckit の 残りのプロンプトの調整。 clarify は以下のようにしたい。
    推奨度と理由をつけて選択肢を提示します。（推奨度：⭐の5段階評価）。質問は最大3つまでとする。選択肢を提示するときは、常に考えられる選択肢を5～7個リストアップし、有力なgit checkout -b Skills2～4個に絞り込みます。
      - clarify の修正できたけど、このあとのPLANとかでPATHが変更になったら再度調整する部分が出てくるので注意。(IMPL_PLAN / TASKS / plan.md / tasks.md まわりは、今のところ既存ロジックをそのまま維持した。後から調整するかも)
      - なので、全体が調整できたあとに、再度スクリプト内のPATHを見直す
  - Plan周り(品質ゲート含む)はdone
- 【done】指示用プロンプトの調整
  - 【done】AGENTS.md, constitution.md も調整。TDD スタイル を維持しながら、このディレクトリ構造に合わせたい。さらに、全体アーキテクチャ → マイクロサービス という構造にしたいので、architecture/ の作成や全体アーキテクチャの ExecPlan の作成、マイクロサービスの Spec や ExecPlan を作るように指示したい。技術スタックはCloudflareやNeon等にしたい。
    - 開発ワークフロー
      - 1.  **アーキテクチャ設計**: ユーザーの要求に基づき、全体アーキテクチャ仕様書を生成します。
      - 2.  **詳細設計 & API契約**: 各マイクロサービスフォルダのドキュメントを充実させていく。
      - 3.  **TDDによる実装**: Jules と GitHub Issueの指示に従って実装します。この際、TDDサイクルとTidy First原則を厳格に遵守します。
- Jujutsu のアンイストールが完了した。Jules が並列実装に対応したため、不要になった。ローカルに Jules のメモあり。
  - Jules を使う場合は Issueドリブンになるのでローカルメモ管理方式ではない。Github Copilot も Issueドリブンの仕様になっているのでそれで良いかも。
- 各ステップをゲート制にするために、ゲートを合格しているか確認する用のスクリプトまたはプロンプトを用意する。合格なら次のステップに行けるようにする。
- 毎回このディレクトリ構造になるように、スクリプトを作ってそれを実行すれば、この構造になるなスクリプトを用意したい。
- checklist の対応
  - 【done】テンプレートを配置(templates/checklist)
  - 【done】スクリプトを作成。実行するとテンプレートからチェックリストを持ってきて、各マイクロサービスのフォルダに配置させるやつ。
    - サービスごとの Issue 生成フローを templates/commands などに追加し、誰でも同一テンプレで起票できるよう CLI 化する。
  - 【done】所定のフォルダに配置されたら、あくまでも汎用的なリストになっているため、エージェントに今回のプロジェクトの仕様にないチェック項目は削除させ、必要なものだけ残させるためのコメントを書く。
  - 【done】マイクロサービスの実装が完了するごとにチェックリストを走らせる。その代わり、全体アーキテクチャに対してのチェックは不要。


## /speckit.specify とは？
↓ これを書くのが無理なので、従来の Speckit 通り /speckit.specify "仕様説明" できるように改良した。つまり、specify.md のプロンプトを修正し、feature_list.json を自動で生成するようにさせた。
================================
/speckit.specify --feature-id <ID> "<説明>"
となり、だいぶ使い方が変わった。

【"<説明>" の書き方ガイド】

「<説明>」には、そのフィーチャの仕様を簡潔にまとめます。  
**1〜3文＋箇条書き**が目安です。次の観点を入れると有効です：

---
**主な記載内容**  
- **目的／ユーザー価値** ：何のための機能か  
- **アクター・主要フロー** ：誰が何をしてどうなるか  
- **入力と出力** ：パラメータや画面入力・レスポンス内容など  
- **正常時の完了条件** ：成功メッセージ、HTTPコード、保存データなど  
- **重要なエラー条件・バリデーション** ：必須項目、重複、権限チェックなど  
- **非機能要件** ：性能、可用性、セキュリティ制約など（必要な場合）

---

**フォーマット例（API系）**  
```
/speckit.specify --feature-id F-API-002 "GET /ping: returns 200 with body {status:'ok', uptimeSeconds:int, version:string}. No auth. 100ms以内。エラー時は503 {status:'degraded'}。"
```

**フォーマット例（UI系）**  
```
/speckit.specify --feature-id F-USER-003 "Signup form: fields email/password/name. 必須チェックとパスワード強度。成功でThank You画面へ遷移。メール重複はエラー表示。"
```

---

**ポイント**  
- 実装方法ではなく「何を達成すべきか」を書く  
- 重要なエッジケースがあれば1〜2個だけ簡潔に加えると精度UP  
- 複数フィーチャ生成時は、それぞれの役割に合わせて説明文を調整するとSpecが書きやすくなります
================================


## speckit.checklist とは？
ソフトウェア開発における「機能の要件定義（仕様書）」が適切に書かれているかを検証するためのチェックリストを作成させるためのルールセットです。
つまり、開発者がコードを書く前や、仕様レビューの段階で、「この仕様書で開発を進めて大丈夫か？」を判断するための品質保証ツールとして機能するように設計された品質チェックゲート。
通常は speckit.plan の前に実行します。speckit.checklist は、「仕様書（spec.md）が曖昧でないか？」「考慮漏れがないか？」をチェックするためのものです。「コードが正しいか」を確認するものではなく、「仕様書が詳しいか」を確認するリストを作るためのもの。
コードレビューは最後にやる。

使い方例:
```
/speckit.checklist 目的:
- マイクロサービスアーキテクチャの要件定義に漏れがないか確認したい。
- 特に「データ整合性」「分散トレーシング」「耐障害性」「オブザーバビリティ」「通信とAPI契約」の要件が spec.md に具体的に定義されているか厳しくチェックしてください。

---

/speckit.checklist 目的:
- セキュリティの要件定義に漏れがないか確認したい。
- 現時点では個人&ローカル開発メインであるため、最小セットでチェックしてください。
- 大規模なチェックは不要ですがバックエンド、データ保護、APIに関する項目はspec.md に具体的に定義されているか厳しくチェックしてください。

---

アプリケーションにLLMを搭載する場合は下記も実施。

/speckit.checklist 目的:
- LLMアプリケーションの要件定義に漏れがないか確認したい。
- 以下の「参照ガイドライン」にある各項目について、「そのアーキテクチャや運用方針が設計として spec.md に明記されているか」 厳しくチェックしてください。

- LLMの責務範囲（「思考」と「ツール実行」の分離など）がSpecに定義されているか。
- プロンプトのコード化、ディレクトリ構成、バージョン管理方針が定義されているか。
- 履歴の圧縮戦略（要約・抽出・切断）が具体的に定義されているか。
- LLM出力のパース失敗時のフォールバックや、型・権限のバリデーション方針が定義されているか。
- ステートレスな設計原則（サーバーメモリに依存しない）が明記されているか。
- 処理の中断・再開APIのインターフェース設計が含まれているか。
- ヒューマン・イン・ザ・ループ（人間への確認・通知）が必要な場合、そのフローとツール定義が存在するか。
- エージェントの実行ループ（思考→ツール→更新）のロジックと、リトライ/バックオフ戦略が定義されているか。
- ツール実行エラーや例外をコンテキストにどうフィードバックするかの戦略（要約して再試行など）が定義されているか。
- エージェントの責務は適切に分割されているか（1エージェントの想定ターン数やSub-Agent化の方針）。
- 同時実行時の整合性制御（楽観ロックなど）の方針が定義されているか。
```

- 正式な品質ゲートはすでに specify の requirements.md ＋ scripts/validate_spec.sh に決まっているので、
/speckit.checklist はその「上に乗るオプション機能」として修正した。
→ 「ドメイン別の追加チェック（ux.md, api.md, security.md など）」に特化して調整。


## speckit.plan とは？
- **plan は「フィーチャ単位」**で持つ（今の setup-plan.sh 設計に合わせる）
- **エピック単位では「軽量 design/index.md」**で、フィーチャ間のつながりや共有コンテキストを管理する → インデックスの追加した
- 実行すると自動的に PlanQualityGate.md が作られる


### エピックの中に複数のフィーチャが紐づく場合、フィーチャ同士で連携するケースもありえますか？
これは 「ありえる」どころか、むしろ普通に起こる前提で考えてよさそうです。
例：
  F-USER-001: signup UI
  F-USER-002: email verification
  → 仕様的にも実装的にも相互に前提関係・依存が出るのが自然

この「フィーチャ同士の関係」「どちらが先か」「どこで統合されるか」を説明するのは、exec-plan.md（エピック単位の Plan）と architecture/ の役割で、
plan.md（implementation plan）は **「1フィーチャを具体的にどう実装するか」**にフォーカスさせるのが分担として綺麗です。

1フィーチャ = 1つの spec + checklist + impl-plan + 周辺設計（research.md など）
→ ドキュメントは 細かく分かれるが、それぞれが小さいので読みやすい。
ドキュメントのボリュームは大きくなるけど、Jules の実行単位としてはこれくらい小さくしないと安定しないかもしれない。
フィーチャ同士の連携や優先度、依存関係はエピック側が俯瞰して管理すればよい。

## 方針
- 作業環境
  - PowerShell ではなく WSL で作業しないとちゃんとプロンプトを読み込んでくれないので、ターミナルでは WSL を起動する。
- 結論から言うと、この speckit の性質と「長期間動くエージェント＋ブランチ運用」を考えると、仕様書 spec はフィーチャ単位で作るほうがエージェントはかなり扱いやすいです。
ただし「エピック単位の視点」は ExecPlan 側でちゃんと持つ、という役割分担にするとバランスが良いです。
/speckit.specify は「1 回のコマンド＝1 個の機能説明＝1 個のブランチ」という動きなので、
1 ブランチ ↔ 1 フィーチャ ↔ 1 spec.md ↔ 1 checklist
という対応にすると、エージェント側のメンタルモデルがシンプルになる。
長期間動くエージェントにとっては：
- 小さめの spec（1 フィーチャ分）だと、「毎回少しだけ進めて成果物を残す」単位が明確
- ブランチと spec が 1 対 1 なので、「今どの spec を編集すべきか」で迷わない
一方、エピック全体の見取り図や優先順位は、ExecPlan 側の Progress / Plan of Work / Context and Orientation でまとめて持てばよいので、
「エピックの視点」は ExecPlan に寄せ、仕様の細かさはフィーチャ側に寄せるという分担がきれいにハマる。
- AIコーディングの心得
  - https://qiita.com/chomado/items/764e67e104843a22bcde
  - AI 駆動開発はマイクロサービスに向いててモノリスには向かない
  - AI は便利だが、嘘をついたり誤魔化したり嬉々として破壊的変更をするので、うまく使おう
  - 常に検証・テスト・レビューを実施​
  - /speckit.checklist
  - /speckit.analyze

### メリット
speckit 側：
- 「どのフィーチャの spec / checklist を編集すべきか」を
- features[].spec_path / features[].checklist_path から機械的に決定可能。

ExecPlan 側：
- epics[].exec_plan_path だけ見れば「このエピック全体の計画書」に飛べる。
- ExecPlan 内から features の ID（F-XXX-YYY）を列挙して参照できる。

エージェント：
- 「今 F-USER-001 をやっている」＝
  - 見る spec: features[F-USER-001].spec_path
  - 直す checklist: features[F-USER-001].checklist_path
  - 所属するエピックの計画: epics[epic_id].exec_plan_path
というシンプルな 3 つの参照で済む。


## done
- PLANS.md の修正
- specify.md の修正(これでコマンドが使えるようになった)
- 以下、チェックリスト周りの調整
  - checklist.md
  - checklist-template.md
- 以下、仕様周りの調整
  - specify.md
  - spec-template.md
- Speckit リポジトリのチェックリストが4つくらいあったので、それも取り入れたい。
- 以下、プラン周りの調整
  - plan.md
  - plan-template.md
  - setup-plan.sh (調整は不要だったので元のまま)
  - setup-plan.ps1 (調整は不要だったので元のまま)
  - PLANS.md の修正が必要になったので修正 (design/index.md の内容を追加)
- システム全体のアーキテクチャまで細かいドキュメントは不要だったため、オンボーディングの修正
  - 「システムレベルは exec-plan + design/index.md に絞る」
  - 「「細かい設計・plan・research などはサービス単位の feature に全部寄せる」
- 以下、タスク周りの調整
  - tasks.md
  - tasks-template.md
- analyze.md
- scripts フォルダの中にあるファイルの整合性を一通りチェック
- templates フォルダの中にあるファイルの整合性を一通りチェック

---

# 長期稼働型 AI エージェント

このリポジトリは、**長期稼働するAIコーディングエージェントと人間が協働するため**に設計されています。

主要な概念は以下の通りです：
- 自明な作業以外のすべての作業は、**機能仕様書 (Feature Spec)** と **実行計画 (ExecPlan)** によって主導されます。わざわざ計画書を作るまでもない小規模な作業では作成しません。
- 仕様書 (Specs) は **機能単位 (per-feature)** です（小さな単位）。
- 実行計画 (ExecPlans) は **エピック単位 (per-epic)** です（より大きな作業単位）。
- 重要なことはすべてファイルに書き込まれるため、ステートレスなエージェントであっても常に途中から再開できます。

## コンセプト

- 人間エンジニアの習慣を“外部成果物”として強制する。
- 「ハーネス」というのは、エージェントの振る舞いを決める外側の仕組みのこと。
- Anthropic は、人間のエンジニアがふだん行っていること（タスク分解、チケット管理、コミットログ、テスト、進捗メモなど）を、「ファイルやスクリプトという形の成果物として必ず残させる」ようにした。このやり方をエージェントも真似できるようにした。

## 用語と関係性

- AI-Agent-progress.txt: 「時間軸のログ」（セッション横断で何がいつ起きたか）
  - いつ何が起きたかの高レベルな履歴 → AI-Agent-progress.txt を時系列に追えば分かる。ExecPlan の Progress 更新履歴など。
- ExecPlan: 「エピック単位の設計＋作業計画＋進捗＋決定」（そのエピックに閉じたストーリー）
  - 細かいストーリーと背景 → ExecPlan を読めば分かる。
- architecture/: 「システム全体の設計図」（静的なアーキテクチャの説明）
  - 「いま・あるいは目指すべきシステム構造」を、実装から少し距離をおいて説明する層。
- plans/system/: 「システム全体エピック用の ExecPlan」（アーキテクチャを“実現・変更するための計画書」）
  - architecture に書かれた方向性・設計を、実際のコードベースに落とし込むためのステップバイステップの計画。

| 視点  | AI-Agent-progress.txt                     | ExecPlan (`exec-plan.md`)            |
| --- | ----------------------------------------- | ------------------------------------ |
| 単位  | リポジトリ全体・全エピック横断                           | **1 エピックごと**（`EPIC-XXX-YYY` 単位）      |
| 中身  | 時系列のイベントログ（いつ・何が行われたかの一行メモ）               | 目的・文脈・作業計画・進捗・決定・振り返りを含む**長文ドキュメント** |
| 時間軸 | セッション横断・全期間                               | そのエピックのライフサイクル                       |
| 粒度  | 「○○を実行した」「spec check FAILED」など比較的ざくっとした記録 | どのファイルをどう編集し、どんなコマンドをどう実行するかまで詳細     |
| 使い道 | ハーネス視点の監査ログ・CI やエージェントの挙動トレース             | 実装者／エージェントが**このエピックを完遂するために読む“手順書”** |

```text
architecture/
  ├── system-architecture.md
  ├── service-boundaries.md
  ├── deployment-topology.md
  └── diagrams/
       ↑
       │（システムの「あるべき姿」「全体像」を説明）
       │
plans/system/
  └── EPIC-SYS-001-foundation/exec-plan.md
       ↑
       │（architecture を前提に、
       │  「このリポジトリで何をどう変えるか」を落とし込む）
       │
services/, tests/, scripts/
  （ExecPlan に従って、実際のコード・テスト・スクリプトが変更される）
```

## 全体チェーン

ExecPlan → design/index.md → 各 feature の impl-plan → tasks.md

- /speckit.plan … フィーチャごとの impl-plan と設計 artifacts を作る
- /speckit.tasks … その impl-plan ＋設計 artifacts から「実行タスク」を起こす

## 品質ゲート

- Spec Kit は「specify → clarify → (仕様品質ゲート: scripts/validate_spec.sh) → Plan → (Plan品質ゲート: scripts/validate_plan.sh) → Tasks  → (Task品質ゲート) → analyze → Implement → (実装ゲート: コード&セキュリティレビュー)」のゲート制で回すので、1つのプロンプトに詰め込みすぎないこと
- /plan は Plan を作るだけ。タスク分解は /speckit.tasks、実装は /speckit.implement に流すのが基本ラインです。
- /speckit.plan で生成されるものは以下。以下をPlan品質ゲートでチェックする
  - impl-plan.md
  - research.md
  - data-model.md
  - contracts/
  - quickstart.md

- Plan品質ゲートのステップ
  - AIエージェントのレビューで 各フィーチャの `checklists/PlanQualityGate.md` を埋める。/plan コマンド実行で自動的に PlanQualityGate.md が作成される。

## 実装

- Jules で Issue ドリブンにするつもりで、自律的に情報収集してくれるはずだけど、GitHub Copilot の場合は以下のような指摘もある。
  - ただし、エージェントが適切に動作するためには、Issue に必要な情報が揃っていることが大前提です。Issue Template を整備して、背景・要件・受け入れ条件などを漏れなく記載する習慣をつけましょう。agents.md でどれだけ良い指示を書いても、Issue の情報が不足していては効果が薄れてしまいます。
- 精度が出ない場合は Issue にもしっかり情報を書いた方が良いかも

## ワークフロー
====== 全体の確認 ===============
1. AGENTS.md の読み込み
1. ルートディレクトリの `README.md` を確認
1. constitution.md ← これは必要なタイミングで読み込んでもらえば良い？
1. `docs/onboarding.md`を確認
1. PLANS.mdを確認  ← オンボーディングの中で指示している
====== 詳細の確認 ===============
1. 自分の担当範囲を確認

============================
1. specify
2. clarify
3. checklist
4. plan         
5. tasks
6. analyze      ← ここまで終わった
7. implement    ← doing。Issue テンプレート作る ← Issue テンプレートは作った
8. review

## Onboarding

このリポジトリで具体的な作業を始めるときは、詳細な手順やディレクトリ構成、`/speckit.*` フローや `scripts/validate_spec.sh` の使い方をまとめた
* `docs/onboarding.md`
を最初に参照してください。

以降のセッションでは、README を毎回読み直す必要はなく、`docs/onboarding.md` と各 ExecPlan / spec を見れば十分です。

## リファレンス

- https://github.com/github/spec-kit

- https://www.anthropic.com/engineering/effective-harnesses-for-long-running-agents

- https://note.com/smorce/n/nf836fdeff03d

- https://www.philschmid.de/agents-2.0-deep-agents


======

# [1回目]矛盾がないかチェックしてもらった。プロンプト周りは調整が必要そう

※「完了するまで応答しない」というビーストモード要件は対話型環境の制約で満たせませんでしたが、求められた監査作業は完了済みです。

## 方針準拠状況

- **Initializer agent（評価: 部分遵守）**  
  ハーネスの骨組みや `feature_list.json` 自体は存在するものの、初期化結果が未完成です。`F-SYS-001` の spec/checklist へのパスが宣言されているのに `plans/system/EPIC-SYS-001-foundation/` には features ディレクトリすら無く、ExecPlan の Progress も一度も更新されていません。結果として「環境初期化＋機能リストを作る」というゴールが中途半端なままで、以降のエージェントが仕様の所在を特定できません。至急 `plans/system/EPIC-SYS-001-foundation/features/F-SYS-001/` を実体化し、Initializer ログ（`AI-Agent-progress.txt`）に初期化ステップを詳細記録してください。  
```26:64:harness/feature_list.json
    {
      "id": "F-SYS-001",
      "epic_id": "EPIC-SYS-001-FOUNDATION",
      "title": "Repository scaffold initialized",
      "spec_path": "plans/system/EPIC-SYS-001-foundation/features/F-SYS-001/spec.md",
      "checklist_path": "plans/system/EPIC-SYS-001-foundation/features/F-SYS-001/checklists/requirements.md"
    },
```
```24:33:plans/system/EPIC-SYS-001-foundation/exec-plan.md
## Progress
- [ ] (YYYY-MM-DD hh:mmZ) Repository layout with architecture, plans, services, tests, and docs created.
- [ ] (YYYY-MM-DD hh:mmZ) Harness files (`init.sh`, `feature_list.json`, etc.) added and validated.
```

- **Coding agent の単機能・段階的実装（評価: 未遵守）**  
  Coding Agent 向け ExecPlan 群はすべてプレースホルダのままで、Progress/Decision/Validation が空欄です。機能仕様も `TODO` だけで、実装対象を明示できていません。この状態では「単一機能に集中し、段階的に実装する」フローを実行しようがありません。まず各 feature spec／checklist を実データで埋め、ExecPlan の Progress を 1 ステップずつ更新して履歴が残る状態にしてください。  
```24:33:plans/services/api-gateway/EPIC-API-001-routing/exec-plan.md
## Progress
- [ ] (YYYY-MM-DD hh:mmZ) Define route handlers in `services/api-gateway/src`.
- [ ] (YYYY-MM-DD hh:mmZ) Add unit tests for the routing handlers.
```
```1:3:plans/services/api-gateway/EPIC-API-001-routing/features/F-API-001/spec.md
# F-API-001 Spec
TODO: Document the GET /health spec for the API gateway routing epic.
```

- **自動化された E2E テスト（評価: 未着手）**  
  `scripts/run_all_e2e_tests.sh` と `tests/e2e/` はテンプレートのみで、実際のシナリオや検証コマンドが一切ありません。E2E ツールチェーンが空のため、仕様通りの「自動化ツールを用いた E2E テスト」は実行不可能です。最低限、ハーネスから呼び出せる smoke シナリオを 1 本追加し、スクリプト内で実際にテストランナーを起動するよう更新してください。  
```1:4:scripts/run_all_e2e_tests.sh
#!/usr/bin/env bash

echo "[run_all_e2e_tests.sh] Placeholder - run end-to-end suites."
```

- **セッション開始時の状況把握（評価: 未遵守）**  
  `Coding Agent 用 System Prompt` には毎セッションで `PLANS.md` や `harness/feature_list.json` を読み、進捗ログを更新する手順が定義されていますが、実際のログ（`harness/AI-Agent-progress.txt`）には初期化時の 1 行しかなく、以降のセッションで状況把握や報告が行われた形跡がありません。ハーネスが生きていないため、長期実行で前提とする「コンテキストをログで受け渡す」仕組みが機能していません。今後の作業では各セッション終了時に必ずログ行と ExecPlan の Progress を更新し、破綻を検知できるようにしてください。  
```1:5:harness/AI-Agent-progress.txt
# Long-running Agent Progress Log
# Each session appends a short summary in plain text.
...
2025-01-01T00:00:00Z | initializer-agent | EPIC-SYS-001-FOUNDATION | F-SYS-001 | Repository scaffold created, PLANS.md and initial ExecPlans added.
```
```8:33:Coding Agent 用 System Prompt テンプレート.md
At the beginning of each session:
1. Orientation
   - Run `pwd` ...
   - Read:
     - PLANS.md
     - harness/feature_list.json
...
```

## 早期アクションの提案

- 初期化漏れ（system epic の specs/チェックリスト未生成、ExecPlan progress 未更新）を最優先で埋めて、Initializer の成果物を完了扱いにする。
- 各 feature spec を `/speckit.specify` → `/speckit.clarify` フローで実内容に書き換え、Plan 品質ゲートの前提を整える。
- 少なくとも 1 本の自動化テスト（ユニット＋E2E）を実装し、`harness/init.sh` とテストスクリプトが実コマンドを叩くよう改修する。
- 以降の Coding Agent セッションごとに、`AI-Agent-progress.txt`・ExecPlan Progress・feature status を必ず更新し、状況把握プロセスを実際に運用する。

外部の最新ウェブ情報は今回の監査では必要ありませんでしたが、追加リサーチが必要になった場合はウェブ検索を行います。