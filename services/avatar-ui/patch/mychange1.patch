diff --git a/docs/decisions.md b/docs/decisions.md
index cf78b00113842d17f2ba388aa1641e97c6105c44..5f37e99ae4e6f8cacc68d38edfc28aa79f5bdab4 100644
--- a/docs/decisions.md
+++ b/docs/decisions.md
@@ -43,25 +43,33 @@ Each entry should follow this format:
     - plans/services/api-gateway/EPIC-API-002-minirag/exec-plan.md (Decision Log)
 
 - ID: DEC-2026-002
   Date: 2026-01-03
   Scope: service:avatar-ui
   Related epics: EPIC-AVATAR-001-DIARY-MINIRAG
   Summary: Finalize diary conversations via explicit UI action and register structured entries to MiniRAG with fixed workspace "diary".
   Details: See ExecPlan at:
     - plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/exec-plan.md (Decision Log)
 
 - ID: DEC-2026-003
   Date: 2026-01-03
   Scope: service:avatar-ui
   Related epics: EPIC-AVATAR-001-DIARY-MINIRAG
   Summary: Persist search toggle/top_k per thread on the server and distribute defaults via /agui/config for tool + UI alignment.
   Details: See ExecPlan at:
     - plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/exec-plan.md (Decision Log)
 
 - ID: DEC-2026-004
   Date: 2026-01-03
   Scope: service:avatar-ui
   Related epics: EPIC-AVATAR-001-DIARY-MINIRAG
   Summary: Update user profiling via diff-based updates that never overwrite non-empty values with empty data and surface failures in UI without blocking diary registration.
   Details: See ExecPlan at:
     - plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/exec-plan.md (Decision Log)
+
+- ID: DEC-2026-005
+  Date: 2026-01-03
+  Scope: service:avatar-ui
+  Related epics: EPIC-AVATAR-001-DIARY-MINIRAG
+  Summary: Validate profiling updates against the default profile schema and apply only above a confidence threshold.
+  Details: See ExecPlan at:
+    - plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/exec-plan.md (Decision Log)
diff --git a/harness/AI-Agent-progress.txt b/harness/AI-Agent-progress.txt
index 56c7ae950a1c63da56fde3054bb8b7bd8fca7b03..e83d64b078b4425af46399fb9789a25a3fae85b5 100644
--- a/harness/AI-Agent-progress.txt
+++ b/harness/AI-Agent-progress.txt
@@ -80,25 +80,27 @@ target: plans/services/api-gateway/EPIC-API-002-minirag/features/F-API-002/check
 [2026-01-02] F-API-002 spec/tasks のMEDIUM指摘対応（LLM明記/性能・依存障害テスト追加）
 2026-01-02T09:17:44Z | implementation-agent | EPIC-API-001-MINIRAG-DEMO-UI | F-API-003 | Added static MiniRAG demo UI, puppeteer E2E scenario, and updated scripts/README.
 2026-01-02T09:18:43Z | codex | EPIC-API-002-MINIRAG | F-API-002 | api-gateway に MiniRAG API/リポジトリ/スキーマ/テスト/E2E/スクリプトを追加。検証は未実行。
 2026-01-02T12:56:25Z | codex | EPIC-API-002-MINIRAG | F-API-002 | scripts/run_all_unit_tests.sh PASSED (5 tests).
 2026-01-02T14:04:00Z | codex | EPIC-API-002-MINIRAG | F-API-002 | Docker Postgres(AGE/pgvector) 起動、MINIRAG API 起動後に scripts/run_all_e2e_tests.sh PASSED。
 2026-01-03T09:20:06Z | codex | EPIC-AVATAR-001-DIARY-MINIRAG | F-AVATAR-001 | avatar-ui 日記/MiniRAG連携の仕様・設計成果物を追加し、アーキテクチャ文書を更新。
 [2026-01-03 09:20Z] spec quality check: PASSED
 target: plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-001/checklists/requirements.md
 [2026-01-03 09:20Z] plan quality check: PASSED
 target: plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-001/checklists/PlanQualityGate.md
 [2026-01-03 11:24Z] spec quality check: PASSED
 target: plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-001/checklists/requirements.md
 [2026-01-03 11:24Z] plan quality check: PASSED
 target: plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-001/checklists/PlanQualityGate.md
 2026-01-03T11:25:50Z | codex | EPIC-AVATAR-001-DIARY-MINIRAG | F-AVATAR-001 | tasks.md を生成（avatar-ui 日記構造化 + MiniRAG 連携）。
 2026-01-03T11:52:13Z | implementation-agent | EPIC-AVATAR-001-DIARY-MINIRAG | F-AVATAR-001 | Implemented MiniRAG diary finalize/search endpoints, UI controls, and settings defaults for avatar-ui.
 2026-01-03T13:30:00Z | codex | EPIC-AVATAR-001-DIARY-MINIRAG | F-AVATAR-002 | プロファイリング更新の spec/impl-plan/research/data-model/contracts/quickstart/tasks を作成し、設計インデックスと決定ログを更新。
 [2026-01-03 16:42Z] spec quality check: PASSED
 target: plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/checklists/requirements.md
 [2026-01-03 16:42Z] plan quality check: PASSED
 target: plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/checklists/PlanQualityGate.md
 [2026-01-03 16:42Z] spec quality check: PASSED
 target: plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/checklists/requirements.md
 [2026-01-03 16:42Z] plan quality check: PASSED
 target: plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/checklists/PlanQualityGate.md
+
+2026-01-03T17:06:11Z | implementation-agent | EPIC-AVATAR-001-DIARY-MINIRAG | F-AVATAR-002 | Added profiling update flow, schema validation, UI warning, and merge tests.
diff --git a/harness/feature_list.json b/harness/feature_list.json
index 45ef7db3f797ba39e75ae31716af5d1853c39206..6157a6aed4ba7bcaeea5211110b8a9a6b6e27144 100644
--- a/harness/feature_list.json
+++ b/harness/feature_list.json
@@ -91,51 +91,51 @@
       "services": ["frontend", "api-gateway"],
       "status": "passing",
       "tags": ["frontend", "demo-ui"],
 
       "spec_path": "plans/services/frontend/EPIC-API-001-minirag-demo-ui/features/F-API-003/spec.md",
       "checklist_path": "plans/services/frontend/EPIC-API-001-minirag-demo-ui/features/F-API-003/checklists/requirements.md"
     },
     {
       "id": "F-AVATAR-001",
       "epic_id": "EPIC-AVATAR-001-DIARY-MINIRAG",
       "title": "Diary conversation structuring + MiniRAG search integration",
       "description": "Gemini conversations are finalized into structured diary entries and stored in MiniRAG; Gemini can retrieve past diary context on demand.",
       "services": ["avatar-ui", "api-gateway"],
       "status": "passing",
       "tags": ["frontend", "agent", "rag"],
 
       "spec_path": "plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-001/spec.md",
       "checklist_path": "plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-001/checklists/requirements.md"
     },
     {
       "id": "F-AVATAR-002",
       "epic_id": "EPIC-AVATAR-001-DIARY-MINIRAG",
       "title": "Diary conversation profiling update",
       "description": "User-only transcript analysis updates a fixed-profile document after diary finalization, with failure notification in UI.",
       "services": ["avatar-ui"],
-      "status": "failing",
+      "status": "passing",
       "tags": ["agent", "profiling", "diary"],
 
       "spec_path": "plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/spec.md",
       "checklist_path": "plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/checklists/requirements.md"
     },
     {
       "id": "F-USER-001",
       "epic_id": "EPIC-USER-001-ONBOARDING",
       "title": "Signup page basic UI",
       "description": "User can open /signup and see the signup form.",
       "services": ["api-gateway"],
       "status": "failing",
       "tags": ["frontend", "user-flow"],
 
       "spec_path": "plans/services/user-service/EPIC-USER-001-onboarding/features/F-USER-001/spec.md",
       "checklist_path": "plans/services/user-service/EPIC-USER-001-onboarding/features/F-USER-001/checklists/requirements.md"
     },
     {
       "id": "F-USER-002",
       "epic_id": "EPIC-USER-001-ONBOARDING",
       "title": "Signup API endpoint",
       "description": "POST /api/users creates a user and returns 201.",
       "services": ["api-gateway", "user-service"],
       "status": "failing",
       "tags": ["backend", "api"],
diff --git a/plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/exec-plan.md b/plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/exec-plan.md
index 2c16ef6584615baefd722cf7936b971949422a8d..6e807814611edb54ebc1d9cbc51165f4af8e4be4 100644
--- a/plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/exec-plan.md
+++ b/plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/exec-plan.md
@@ -1,98 +1,105 @@
 # EPIC-AVATAR-001-DIARY-MINIRAG: 日記会話の構造化とMiniRAG連携
 
 This ExecPlan is a living document. The sections `Progress`, `Surprises & Discoveries`, `Decision Log`, and `Outcomes & Retrospective` must be kept up to date as work proceeds.
 
 This repository stores the ExecPlan guidelines in `./PLANS.md` at the repository root. This document must be maintained in accordance with PLANS.md.
 
 This epic has an epic-level design index at `plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/design/index.md`. It contains a feature map, shared entities, API/contract references, and the cross-feature flow summary for this epic. The ExecPlan remains self-contained and repeats the critical context below.
 
 ## Purpose / Big Picture
 
 ユーザーは avatar-ui で Gemini と日記会話を行い、会話終了時にボタン操作で会話内容を構造化し、MiniRAG に登録できるようになります。さらに、Gemini は必要時に MiniRAG 検索を自律的に呼び出し、過去日記のコンテキスト（doc_id / summary / body）だけを受け取って会話を継続できます。UI には検索の ON/OFF トグルと top_k 設定が表示され、ユーザーが主導で体験を制御できることが可視化されます。
 
 ## Related Features / Specs
 
 - F-AVATAR-001: 日記会話の構造化登録とMiniRAG検索連携
   - Spec: `plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-001/spec.md`
   - Status: implemented
 - F-AVATAR-002: 日記会話のプロファイリング更新
   - Spec: `plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/spec.md`
-  - Status: planned
+  - Status: implemented
 
 ## Progress
 
 - [x] (2026-01-03 09:13Z) Epic の初期 ExecPlan と設計ドキュメント骨子を作成した。
 - [x] (2026-01-03 09:20Z) Spec / Impl Plan / Research / Data Model / Contracts / Quickstart を整備し、品質ゲートを PASS にした。
 - [x] (2026-01-03 09:20Z) avatar-ui のサービス設計ドキュメントを更新し、計画との差分を解消した。
 - [x] (2026-01-03 09:20Z) 実装準備としてタスク分解を完了し、Jules Issue 作成へ移行した。
 - [x] (2026-01-03 12:20Z) MiniRAG クライアントと日記確定 API を実装し、UI に検索トグルと会話確定を追加した。
 - [x] (2026-01-03 12:20Z) settings.json5 と README を更新し、日記ワークフローと設定項目を反映した。
 - [x] (2026-01-03 13:30Z) F-AVATAR-002 の spec/impl-plan/research/data-model/contracts/quickstart/tasks を作成した。
+- [x] (2026-01-03 17:06Z) プロファイル差分更新モジュールと UI 警告表示を実装し、設定とテストを追加した。
 
 ## Surprises & Discoveries
 
 - Observation:
 
   Spec と Plan の品質ゲートは新規チェックリストに対して PASSED となった。
 
   Evidence:
 
     [2026-01-03 09:20Z] spec quality check: PASSED
 
     [2026-01-03 09:20Z] plan quality check: PASSED
 
 ## Decision Log
 
 - Decision: 会話終了はユーザーのボタン操作で確定し、確定時に Gemini が会話を分析して重要度・サマリー・セマンティック記憶・エピソード記憶を生成する。
   Rationale: 日記用途ではユーザーの「ここまで」を明示できる UX が必要であり、自動終了判定より誤登録を減らせるため。
   Date/Author: 2026-01-03 / codex
 
 - Decision: MiniRAG の検索コンテキストは doc_id / summary / body の上位N件のみを Gemini に渡す。
   Rationale: 回答そのものではなく文脈だけを渡すことで、Gemini が会話を継続しやすく、過剰な情報注入を避けられるため。
   Date/Author: 2026-01-03 / codex
 
 - Decision: workspace は固定値 `diary` とし、UI で変更しない。
   Rationale: 個人日記用途で運用が単純化でき、検索フィルタも明確になるため。
   Date/Author: 2026-01-03 / codex
 
 - Decision: 検索トグルと top_k 設定は server 側でスレッドごとに保持し、UI 初期値は `/agui/config` から配布する。
   Rationale: UI と検索ツールが同じ設定ソースを参照でき、Gemini のツール呼び出しと UX の整合性を保てるため。
   Date/Author: 2026-01-03 / codex
 
 - Decision: プロファイル更新は差分適用とし、既存の非空値は空で上書きしない。
   Rationale: LLM の欠落や誤りによる情報損失を避け、更新の安全性を高めるため。
   Date/Author: 2026-01-03 / codex
 
 - Decision: プロファイリング失敗は日記登録の成否と切り離し、UI に警告表示を出す。
   Rationale: 日記登録の成功体験を維持しつつ、失敗を利用者に明示して再試行可能にするため。
   Date/Author: 2026-01-03 / codex
 
+- Decision: プロファイル差分は既定のプロフィールスキーマでパス検証し、信頼度閾値未満は反映しない。
+  Rationale: 固定項目の安全性を保ち、低信頼の推定を避けるため。
+  Date/Author: 2026-01-03 / codex
+
 ## Outcomes & Retrospective
 
 UI への検索トグル・top_k・会話確定ボタン追加と、FastAPI 側の MiniRAG 連携 API を実装した。search_diary ツール経由で Gemini が過去日記検索を行えるようになり、会話確定の結果が UI に表示される。
 
+日記確定後にユーザー発話のみを分析して固定プロフィールを差分更新するフローを追加し、profiling 失敗時は UI に警告表示が出るようにした。
+
 ## Context and Orientation
 
 このエピックは avatar-ui のみを変更対象とし、MiniRAG API は既存の api-gateway 側を利用する前提です。avatar-ui にはフロントエンド（`services/avatar-ui/app/`）と FastAPI ベースの AG-UI サーバー（`services/avatar-ui/server/`）があり、UI は `/agui` に接続して Gemini との会話を行います。本機能では UI に「検索トグル」「top_k 設定」「会話確定ボタン」を追加し、サーバー側に MiniRAG 呼び出しと会話構造化のフローを追加します。
 
 重要なファイルは次のとおりです。
 
 - UI: `services/avatar-ui/app/src/renderer/index.html`, `services/avatar-ui/app/src/renderer/main.ts`, `services/avatar-ui/app/src/renderer/style.css`
 - サーバー: `services/avatar-ui/server/main.py`, `services/avatar-ui/server/src/config.py`
 - 設定: `services/avatar-ui/settings.json5`, `.env`（ただし本計画では `.env` を編集しない）
 
 用語:
 
 - 会話確定: ユーザーがボタンを押して「日記の区切り」を宣言する操作。
 - セマンティック記憶: 日記の中に含まれる恒久的な知識・習慣・価値観。
 - エピソード記憶: 日記の中の具体的な出来事や体験。
 - 検索トグル: MiniRAG 検索の使用可否を切り替える UI スイッチ。
 
 ## Plan of Work
 
 まずアーキテクチャ文書と avatar-ui のサービス設計を更新し、MiniRAG 連携がシステムのどこに位置づくかを明確化する。次に、F-AVATAR-001 の仕様・設計成果物を整備し、MiniRAG 登録データの構造と UI/サーバーの責務分担を確定する。最後に、実装のための具体的なファイルと変更内容を Impl Plan に記載し、品質ゲートを通過させる。
 
 ## Concrete Steps
 
 1. アーキテクチャ文書の更新
    - `architecture/system-architecture.md` と `architecture/service-boundaries.md` に diary + MiniRAG 連携の責務を追記する。
diff --git a/plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/quickstart.md b/plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/quickstart.md
index 97cf6d48d436227d0f15625cbe03f3f9c1e6f7c0..780dec5b4e64bbff821ff4ba2dc5bd222b3f928d 100644
--- a/plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/quickstart.md
+++ b/plans/services/avatar-ui/EPIC-AVATAR-001-diary-minirag/features/F-AVATAR-002/quickstart.md
@@ -1,42 +1,45 @@
 # Quickstart: F-AVATAR-002
 
 この手順は avatar-ui だけを変更し、日記確定時にプロファイル更新が行われることを確認する。
 
 ## 前提
 
 - MiniRAG API が起動している
 - avatar-ui の server と app が起動できる（`services/avatar-ui/README.ja.md` を参照）
 - プロファイルは単一ファイルで管理される
 
 ## 手順
 
 1. avatar-ui server を起動する
 
    例:
 
      cd services/avatar-ui/server
      uv run --link-mode=copy python main.py
 
+   必要に応じて `services/avatar-ui/settings.json5` の `profiling` セクションで
+   プロファイリングモデルと最低信頼度を調整する。
+
 2. avatar-ui app を起動する
 
    例:
 
      cd services/avatar-ui/app
      npm install
      npm run dev
 
 3. UI を開き、ユーザー発話を含む会話を行う
 
 4. 「会話確定」ボタンを押す
 
 5. プロファイル更新が行われることを確認する
 
    - `services/avatar-ui/profiling/user_profile.yaml` を開き、空欄だった項目が更新されていること
 
 6. profiling を失敗させた場合、UI に警告メッセージが表示されることを確認する
 
 ## 期待結果
 
 - 会話確定後にプロファイルが更新される
 - 既存の非空値が空で上書きされない
 - profiling 失敗時は UI に警告表示が出る
diff --git a/pyproject.toml b/pyproject.toml
index 1fc3335e5c1667a2d4364fcd567297a3d88a1fda..a4d7501e5a2b70665346a40f88b05e48f38d794a 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -1,32 +1,33 @@
 [project]
 name = "deepagentsspec"
 version = "0.1.0"
 description = "Add your description here"
 readme = "README.md"
 requires-python = ">=3.11"
 dependencies = [
     "accelerate>=1.12.0",
     "aiofiles>=25.1.0",
     "aiohttp>=3.13.2",
     "configparser>=7.2.0",
     "fastapi>=0.128.0",
     "httpx>=0.28.1",
     "json-repair>=0.55.0",
     "networkx>=3.6.1",
     "nltk>=3.9.2",
     "numpy>=2.4.0",
     "pandas>=2.3.3",
     "pipmaster>=1.0.10",
     "psycopg[binary]>=3.3.2",
     "pydantic>=2.12.5",
+    "pyyaml>=6.0.1",
     "pypdf2>=3.0.1",
     "pytest>=9.0.2",
     "python-dotenv>=1.2.1",
     "rouge>=1.0.1",
     "setuptools>=80.9.0",
     "tenacity>=9.1.2",
     "tiktoken>=0.12.0",
     "tqdm>=4.67.1",
     "uvicorn>=0.40.0",
     "xxhash>=3.6.0",
 ]
diff --git a/services/avatar-ui/README.ja.md b/services/avatar-ui/README.ja.md
index 7e39bfebe003f65e12d9c29a2c92ccc1dde447cc..ddd68735625eea9b6f39e31c3e6cfd4b2e0c0a3f 100644
--- a/services/avatar-ui/README.ja.md
+++ b/services/avatar-ui/README.ja.md
@@ -10,66 +10,68 @@ INFO:     127.0.0.1:41016 - "POST /agui/diary/search-settings HTTP/1.1" 200 OK
 が出ればOK。画面のアバター名も変わる。
 
 - WSL 内で:  
   `curl http://127.0.0.1:1686/healthz`
 
 - Windows 側ブラウザで:  
   [http://localhost:1686/healthz](http://localhost:1686/healthz)
 
 
 
 # AVATAR UI
 
 人と AI が共存する次世代インターフェース基盤。  
 Gemini・GPT・Claude 対応。デスクトップで動くエージェント UI。
 
 ![demo](./docs/assets/avatar-ui_demo_02.gif)
 
 ## 特徴
 
 - **マルチLLM対応** – Gemini / OpenAI / Anthropic を設定で切り替え
 - **ツール拡張対応** – 検索エージェント標準搭載。MCP連携・ツール追加可
 - **パーソナライズUI** – 3種のカラーテーマ。アバター変更も自由
 - **デスクトップアプリ** – ローカル動作。macOS / Windows / Linux 対応
 - **商用利用可** – オープンソース（MIT）。個人・商用問わず自由に利用可能
 - **日記 + MiniRAG 連携** – 会話確定ボタンで日記を構造化し MiniRAG に登録、必要時に過去日記のコンテキストを取得
+- **プロファイリング更新** – 会話確定後にユーザーの発話を分析し、固定プロファイルを差分更新（失敗時は警告表示）
 
 ## 使い方
 
 1. アプリ起動 → アバターが待機状態で表示
 2. メッセージ入力 → `Enter` で送信
 3. アバターがリアルタイム応答
 4. 必要に応じて Google 検索を自動実行
 5. 終了：`Ctrl+C`
 
 ## 日記 + MiniRAG 連携（概要）
 
 - UI に「検索トグル」「top_k 設定」「会話確定ボタン」が表示されます。
 - 会話確定ボタンを押すと、Gemini が会話内容を分析し、重要度・サマリー・記憶を抽出します。
 - 抽出結果は MiniRAG に構造化データとして登録されます。
 - 検索トグル ON のときのみ、Gemini が MiniRAG 検索で過去日記を参照します。
 - top_k と検索トグルの初期値は `settings.json5` の `minirag` セクションで調整できます。
+- 会話確定後にユーザー発話のみを分析し、`profiling/user_profile.yaml` が差分更新されます。
 
 ## クイックスタート
 
 ## DeepAgentsSpec での配置
 
 このリポジトリでは、`services/avatar-ui/` に配置済みです。
 以下はこの構成に合わせた最小手順です。
 
 ### 1. 環境変数を用意（必須）
 
 `services/avatar-ui/` 直下に `.env` を作成し、必要な環境変数を設定してください。
 主な必須項目は以下です（値はあなたの環境に合わせて設定）:
 
 - `GOOGLE_API_KEY`（検索サブエージェントを使う場合）
 - `AGENT_ID`
 - `THREAD_ID`
 - `SERVER_HOST`
 - `SERVER_BIND_HOST`（任意、WSL などで 0.0.0.0 バインドしたい場合）
 - `SERVER_PORT`
 - `CLIENT_PORT`
 - `APP_ENV`
 - `SESSION_TIMEOUT_SECONDS`
 - `CLEANUP_INTERVAL_SECONDS`
 
 > 注意: 現行のサーバー実装は `GOOGLE_API_KEY` が未設定だと起動時にエラーになります。
@@ -215,50 +217,61 @@ cp settings.default.json5 settings.json5
 
 デフォルトで Google 検索サブエージェントが有効です（Gemini モデルで動作）。  
 無効化する場合:
 
 ```json5
 "searchSubAgent": {
   "enabled": false
 }
 ```
 
 検索サブエージェントは Gemini API を使用するため、利用には `GOOGLE_API_KEY` の設定が必要です。
 
 ### 日記 + MiniRAG 設定
 
 `settings.json5` の `minirag` セクションで、MiniRAG の接続先と UI のデフォルト値を設定できます。
 
 ```json5
 minirag: {
   baseUrl: "http://localhost:8165",
   workspace: "diary",
   searchEnabledDefault: true,
   topKDefault: 3,
 }
 ```
 
+### プロファイリング設定
+
+`settings.json5` の `profiling` セクションで、プロファイル更新に使うモデルと反映の最低信頼度を設定できます。
+
+```json5
+profiling: {
+  model: "gemini-2.5-flash",
+  minConfidence: 0.6,
+}
+```
+
 ### カスタマイズ一覧
 
 | 項目 | 設定場所 |
 |------|----------|
 | システムプロンプト | `settings.json5` → `server.systemPrompt` |
 | テーマ・色 | `settings.json5` → `ui.theme`, `ui.themes` |
 | アバター画像 | `app/src/renderer/assets/` に配置 |
 | ツール追加 | `server/main.py` → `tools` リスト |
 
 ## ドキュメント
 
 - [設計書](./docs/project.md) – アーキテクチャ、実装詳細、ロードマップ
 - [AG-UI Protocol](https://docs.ag-ui.com/) – プロトコル仕様（公式）
 - [Google ADK](https://google.github.io/adk-docs/) – エージェント開発キット（公式）
 
 ## ライセンス
 
 [MIT License](LICENSE)
 
 © 2025 [SIQI](https://siqi.jp) (Sito Sikino)
 
 ## メモ
 
 フロントエンド（Vite/ブラウザ）と Python（FastAPI）は、それぞれ別プロセスとして同時に起動しています。  
 `services/avatar-ui/scripts/run_dev.sh` は、まず Python サーバー（FastAPI）をバックグラウンドで起動し、次に Vite（フロントエンド）をフォアグラウンドで起動します。
diff --git a/services/avatar-ui/app/src/renderer/main.ts b/services/avatar-ui/app/src/renderer/main.ts
index dacffb2af774dee079f454d7afe8be8378624847..1e48dbc807f8056133f5fb38cca828be457330bd 100644
--- a/services/avatar-ui/app/src/renderer/main.ts
+++ b/services/avatar-ui/app/src/renderer/main.ts
@@ -180,77 +180,86 @@ async function initApp() {
   const fallbackModes = normalizeSearchModes(config.minirag.searchModesDefault ?? ["mini"]);
   const ensureAtLeastOneMode = (modes: string[]) => {
     if (modes.length > 0) {
       return modes;
     }
     return fallbackModes.length > 0 ? fallbackModes : ["mini"];
   };
   const diarySearchSettings = {
     enabled: config.minirag.searchEnabledDefault,
     top_k: config.minirag.topKDefault,
     modes: ensureAtLeastOneMode(normalizeSearchModes(config.minirag.searchModesDefault ?? [])),
   };
 
   // テキスト行を追加（エンジンを介さない即時表示用）
   const appendLine = (className: string, text: string) => {
     const line = document.createElement("div");
     line.className = `text-line ${className}`;
     line.textContent = text;
     outputEl.appendChild(line);
     outputEl.scrollTop = outputEl.scrollHeight;
   };
 
   let isRunning = false; // 多重実行防止フラグ
   let isFinalizing = false;
 
-  const updateFinalizeStatus = (text: string, isError = false) => {
+  const updateFinalizeStatus = (
+    text: string,
+    tone: "default" | "warning" | "error" = "default",
+  ) => {
     if (!finalizeStatus) return;
     finalizeStatus.textContent = text;
-    finalizeStatus.style.color = isError ? "rgba(255, 102, 102, 1)" : "";
+    if (tone === "error") {
+      finalizeStatus.style.color = "rgba(255, 102, 102, 1)";
+    } else if (tone === "warning") {
+      finalizeStatus.style.color = "rgba(255, 196, 102, 1)";
+    } else {
+      finalizeStatus.style.color = "";
+    }
   };
 
   const applySearchSettings = async () => {
     if (!config.agent.threadId) {
       return;
     }
     try {
       const response = await fetch(`${serverBase}/agui/diary/search-settings`, {
         method: "POST",
         headers: { "Content-Type": "application/json" },
         body: JSON.stringify({
           thread_id: config.agent.threadId,
           settings: diarySearchSettings,
         }),
       });
       if (!response.ok) {
         throw new Error(`Search settings update failed: ${response.status}`);
       }
       updateFinalizeStatus("検索設定を更新しました");
     } catch (error) {
       updateFinalizeStatus(
         `検索設定の更新に失敗しました: ${error instanceof Error ? error.message : String(error)}`,
-        true,
+        "error",
       );
     }
   };
 
   if (searchToggle) {
     searchToggle.checked = diarySearchSettings.enabled;
     searchToggle.addEventListener("change", async () => {
       diarySearchSettings.enabled = searchToggle.checked;
       await applySearchSettings();
     });
   }
 
   if (topKInput) {
     topKInput.value = String(diarySearchSettings.top_k);
     topKInput.addEventListener("change", async () => {
       const value = Number(topKInput.value);
       diarySearchSettings.top_k = Number.isNaN(value)
         ? config.minirag.topKDefault
         : Math.min(Math.max(value, 1), 10);
       topKInput.value = String(diarySearchSettings.top_k);
       await applySearchSettings();
     });
   }
 
   if (modeInputs.length > 0) {
@@ -364,51 +373,62 @@ async function initApp() {
       try {
         const response = await fetch(`${serverBase}/agui/diary/finalize`, {
           method: "POST",
           headers: { "Content-Type": "application/json" },
           body: JSON.stringify({
             workspace: diaryWorkspace,
             thread_id: config.agent.threadId,
             messages: transcript,
             search_settings: diarySearchSettings,
           }),
         });
         if (!response.ok) {
           const payload = await response.json().catch(() => ({}));
           throw new Error(payload.detail || `Finalize failed: ${response.status}`);
         }
         const payload = await response.json();
         appendLine(
           "text-line--system",
           `> 日記を登録しました: ${payload.doc_id} (重要度 ${payload.analysis.importance_score})`,
         );
         appendLine(
           "text-line--system",
           `> サマリー: ${payload.analysis.summary}`,
         );
         updateFinalizeStatus("会話確定が完了しました");
+        if (payload.profiling?.status === "failed") {
+          const reason =
+            typeof payload.profiling.message === "string" && payload.profiling.message
+              ? ` (${payload.profiling.message})`
+              : "";
+          appendLine(
+            "text-line--warning",
+            `⚠️ プロファイリングに失敗しました${reason}`,
+          );
+          updateFinalizeStatus("プロファイリングに失敗しました", "warning");
+        }
       } catch (error) {
         appendLine(
           "text-line--error",
           `❌ 会話確定に失敗しました: ${error instanceof Error ? error.message : String(error)}`,
         );
-        updateFinalizeStatus("会話確定に失敗しました", true);
+        updateFinalizeStatus("会話確定に失敗しました", "error");
       } finally {
         isFinalizing = false;
         finalizeButton.disabled = false;
       }
     });
   }
   
   // 初期メッセージ: 設定されたシステムメッセージを使う
   const fullName = config.ui.nameTags.avatarFullName || config.ui.nameTags.avatar || "AGENT";
   if (config.ui.systemMessages.banner1) {
     const banner1 = config.ui.systemMessages.banner1.replace("{avatarFullName}", fullName);
     appendLine("text-line--system", `> ${banner1}`);
   }
   if (config.ui.systemMessages.banner2) {
     appendLine("text-line--system", `> ${config.ui.systemMessages.banner2}`);
   }
 }
 
 // アプリ起動
 initApp().catch(err => console.error("Fatal Error:", err));
diff --git a/services/avatar-ui/app/src/renderer/style.css b/services/avatar-ui/app/src/renderer/style.css
index 748a6f3e58e25907e3f3b2a0a837a9b01eb63a4c..dd127ef3e178226cf67ee981eea075ec805b24cb 100644
--- a/services/avatar-ui/app/src/renderer/style.css
+++ b/services/avatar-ui/app/src/renderer/style.css
@@ -182,50 +182,54 @@ body {
   font-style: italic;
   opacity: 0.9;
 }
 .text-line code {
   background: rgba(var(--theme-color-r), var(--theme-color-g), var(--theme-color-b), 0.15);
   padding: 0.1em 0.3em;
   border-radius: 3px;
 }
 .text-line ul, .text-line ol {
   margin: 0;
   padding-left: 1.5em;
 }
 .text-line li {
   margin: 0;
 }
 .text-line p {
   margin: 0;
 }
 
 .text-line--system { color: var(--col-theme-dim); }
 
 .text-line--error {
   color: rgba(var(--error-color-r), var(--error-color-g), var(--error-color-b), 1);
 }
 
+.text-line--warning {
+  color: rgba(255, 196, 102, 1);
+}
+
 /* AI の提案文などを囲うスタイル */
 .text-line--proposed {
   color: var(--col-theme-text);
   font-family: Consolas, Menlo, monospace;
   background: rgba(0, 20, 10, 0.4);
   padding: 8px;
   border: 1px solid rgba(var(--theme-color-r), var(--theme-color-g), var(--theme-color-b), 0.3);
 }
 
 .text-line--user { color: var(--col-user-text); }
 .text-line--assistant { color: var(--col-theme-text); }
 .text-line--tool { 
   color: var(--col-tool-text);
   font-style: italic;
 }
 
 /* 入力エリア（画面下） */
 #pane-input {
   grid-column: 1 / 3;
   grid-row: 2 / 3;
   display: flex;
   flex-direction: column;
   align-items: stretch;
   gap: 8px;
   padding: 10px 12px; /* 入力枠の余白 */
diff --git a/services/avatar-ui/server/src/config.py b/services/avatar-ui/server/src/config.py
index a46d2007e20080f54db367ae562c1998291bcbb8..74d9c0a9d63d69042f097077c6d8f87a27cf896e 100644
--- a/services/avatar-ui/server/src/config.py
+++ b/services/avatar-ui/server/src/config.py
@@ -94,55 +94,64 @@ class MiniRagSettings(BaseModel, extra="forbid"):
     workspace: str = "diary"
     searchEnabledDefault: bool = True
     topKDefault: int = Field(ge=1, le=10, default=3)
     searchModesDefault: List[str] = Field(default_factory=lambda: ["mini"])
     timeoutSeconds: int = Field(gt=0, default=30)
 
     @field_validator("searchModesDefault")
     @classmethod
     def validate_search_modes(cls, value: List[str]):
         allowed = {"naive", "mini", "light"}
         normalized: List[str] = []
         for mode in value:
             if not isinstance(mode, str):
                 raise ValueError("searchModesDefault must be a list of strings")
             mode = mode.strip()
             if mode not in allowed:
                 raise ValueError(f"searchModesDefault includes unsupported mode: {mode}")
             if mode in normalized:
                 continue
             normalized.append(mode)
             if len(normalized) > 3:
                 raise ValueError("searchModesDefault must include at most 3 modes")
         return normalized
 
 
+# Profiling 設定
+class ProfilingSettings(BaseModel, extra="forbid"):
+    model: str
+    minConfidence: float = Field(ge=0, le=1, default=0.6)
+
+
 # settings.json5 のルートスキーマ
 class AppSettings(BaseModel, extra="forbid"):
     server: ServerSettings
     ui: UiSettings
     minirag: MiniRagSettings
+    profiling: ProfilingSettings = Field(
+        default_factory=lambda: ProfilingSettings(model="gemini-2.5-flash")
+    )
 
 
 # ---------- テーマ解決 ----------
 
 def resolve_theme(ui: UiSettings) -> dict:
     """
     テーマプリセットを解決し、実際に使う色を決定する。
     - ui.theme で指定されたプリセットがあればそれを基準にする
     - 個別指定（themeColor など）があればプリセットより優先する
     """
     resolved = ui.model_dump()
     if ui.themes:
         for preset in ui.themes:
             if preset.name == ui.theme:
                 resolved["themeColor"] = preset.themeColor
                 resolved["userColor"] = preset.userColor
                 resolved["toolColor"] = preset.toolColor
                 break
     resolved.pop("themes", None)
     return resolved
 
 
 # .env から読み込む環境変数のスキーマ
 class EnvSettings(BaseSettings):
     google_api_key: str = Field(alias="GOOGLE_API_KEY")
@@ -246,27 +255,31 @@ LOG_MAX_BYTES = app_settings.server.logMaxBytes
 LOG_BACKUP_COUNT = app_settings.server.logBackupCount
 
 # Session/HITL 設定
 SESSION_TIMEOUT_SECONDS = env_settings.session_timeout_seconds
 CLEANUP_INTERVAL_SECONDS = env_settings.cleanup_interval_seconds
 
 # FastAPI の /agui/config で返すために dict で保持
 _ui_settings = resolve_theme(app_settings.ui)
 
 # クライアントのログ詳細可否（サーバ設定と連動）
 CLIENT_LOG_VERBOSE = (APP_ENV == "dev") or (LOG_BODY is True)
 
 # 検索サブエージェント設定
 SEARCH_SUBAGENT_ENABLED = app_settings.server.searchSubAgent.enabled
 SEARCH_SUBAGENT_MODEL = app_settings.server.searchSubAgent.model
 
 # MiniRAG 設定
 MINIRAG_BASE_URL = app_settings.minirag.baseUrl
 MINIRAG_WORKSPACE = app_settings.minirag.workspace
 MINIRAG_SEARCH_ENABLED_DEFAULT = app_settings.minirag.searchEnabledDefault
 MINIRAG_TOP_K_DEFAULT = app_settings.minirag.topKDefault
 MINIRAG_SEARCH_MODES_ALLOWED = ("naive", "mini", "light")
 MINIRAG_SEARCH_MODES_DEFAULT = app_settings.minirag.searchModesDefault
 MINIRAG_TIMEOUT_SECONDS = app_settings.minirag.timeoutSeconds
 
+# Profiling 設定
+PROFILING_MODEL = app_settings.profiling.model
+PROFILING_MIN_CONFIDENCE = app_settings.profiling.minConfidence
+
 # AG-UI エージェント接続情報（サーバを唯一の真実源とする）
 AGENT_URL = f"http://{SERVER_HOST}:{SERVER_PORT}/agui"
diff --git a/services/avatar-ui/server/src/diary_service.py b/services/avatar-ui/server/src/diary_service.py
index eabcef7f3251b7f47af27913b20995a9ad44e39b..32e1dfd4e5c2e3b2c15ac974f00be1c6433be929 100644
--- a/services/avatar-ui/server/src/diary_service.py
+++ b/services/avatar-ui/server/src/diary_service.py
@@ -1,37 +1,38 @@
 import json
 import logging
 import re
 import uuid
 from dataclasses import dataclass
 from datetime import datetime, timezone
 from typing import Any
 
 from google import genai
 
 from src import config
 from src.minirag_client import MiniRagClient, MiniRagConfig, MiniRagError
+from src.profile_service import ProfilingStatus, run_profiling
 
 
 logger = logging.getLogger(__name__)
 
 
 class DiaryValidationError(ValueError):
     pass
 
 
 class DiaryAnalysisError(RuntimeError):
     pass
 
 
 @dataclass(frozen=True)
 class SearchSettings:
     enabled: bool
     top_k: int
     modes: tuple[str, ...]
 
 
 @dataclass(frozen=True)
 class DiaryAnalysis:
     title: str
     importance_score: int
     summary: str
@@ -71,50 +72,62 @@ def set_search_settings(thread_id: str, settings: SearchSettings) -> SearchSetti
             continue
         normalized_modes.append(mode)
         if len(normalized_modes) >= 3:
             break
     clamped = SearchSettings(
         enabled=settings.enabled,
         top_k=max(1, min(settings.top_k, 10)),
         modes=tuple(normalized_modes),
     )
     _search_settings_by_thread[thread_id] = clamped
     return clamped
 
 
 def format_transcript(messages: list[dict[str, Any]]) -> str:
     lines: list[str] = []
     for message in messages:
         role = message.get("role", "user")
         content = (message.get("content") or "").strip()
         if not content:
             continue
         label = "User" if role == "user" else "Assistant" if role == "assistant" else "System"
         lines.append(f"{label}: {content}")
     return "\n".join(lines)
 
 
+def extract_user_transcript(messages: list[dict[str, Any]]) -> str:
+    lines: list[str] = []
+    for message in messages:
+        if message.get("role") != "user":
+            continue
+        content = (message.get("content") or "").strip()
+        if not content:
+            continue
+        lines.append(content)
+    return "\n".join(lines)
+
+
 def build_analysis_prompt(messages: list[dict[str, Any]]) -> str:
     transcript = format_transcript(messages)
     return (
         "あなたは日記会話を整理するアシスタントです。"
         "以下の会話から日記タイトル、重要度(1-10)、サマリー、"
         "セマンティック記憶、エピソード記憶を抽出してください。"
         "必ず JSON のみを返し、キーは次の通りにすること:\n"
         "title, importance_score, summary, semantic_memory, episodic_memory\n\n"
         "会話:\n"
         f"{transcript}"
     )
 
 
 def _extract_response_text(response: Any) -> str:
     text = getattr(response, "text", None)
     if isinstance(text, str):
         return text
     candidates = getattr(response, "candidates", None)
     if candidates:
         content = getattr(candidates[0], "content", None)
         parts = getattr(content, "parts", None) if content else None
         if parts and hasattr(parts[0], "text"):
             return parts[0].text
     return ""
 
@@ -183,64 +196,66 @@ def build_diary_document(
         "workspace": config.MINIRAG_WORKSPACE,
         "doc_id": _generate_doc_id(now),
         "title": analysis.title,
         "summary": analysis.summary,
         "body": body,
         "importance_score": analysis.importance_score,
         "semantic_memory": analysis.semantic_memory,
         "episodic_memory": analysis.episodic_memory,
         "created_at": now.isoformat(),
         "metadata": {
             "model": config.LLM_MODEL,
             "message_count": len(messages),
             "search_enabled": search_settings.enabled,
             "top_k": search_settings.top_k,
             "modes": list(search_settings.modes),
             "thread_id": thread_id,
         },
     }
 
 
 async def finalize_diary(
     *,
     messages: list[dict[str, Any]],
     thread_id: str,
     search_settings: SearchSettings,
-) -> tuple[str, int, DiaryAnalysis]:
+) -> tuple[str, int, DiaryAnalysis, ProfilingStatus]:
     analysis = await analyze_diary(messages)
     document = build_diary_document(
         messages=messages,
         analysis=analysis,
         thread_id=thread_id,
         search_settings=search_settings,
     )
     try:
         result = await _MINIRAG_CLIENT.bulk_insert([document])
     except MiniRagError as exc:
         raise DiaryAnalysisError(f"MiniRAG bulk insert failed: {exc}") from exc
     inserted = int(result.get("inserted", 1))
-    return document["doc_id"], inserted, analysis
+    user_transcript = extract_user_transcript(messages)
+    profiling_status = run_profiling(user_transcript)
+    return document["doc_id"], inserted, analysis, profiling_status
 
 
 def _extract_search_items(payload: dict[str, Any]) -> list[dict[str, Any]]:
     items: list[dict[str, Any]] = []
 
     # 旧形式: items/documents など
     candidates = payload.get("items") or payload.get("documents") or []
     if isinstance(candidates, list) and candidates:
         for entry in candidates:
             if not isinstance(entry, dict):
                 continue
             items.append(
                 {
                     "doc_id": entry.get("doc_id") or entry.get("id") or "",
                     "summary": entry.get("summary") or "",
                     "body": entry.get("body") or "",
                 }
             )
         return items
 
     # MiniRAG 形式: results -> sources / answer.provenance.chunks
     results = payload.get("results") or []
     if not isinstance(results, list):
         return items
 
diff --git a/services/avatar-ui/server/src/profile_service.py b/services/avatar-ui/server/src/profile_service.py
new file mode 100644
index 0000000000000000000000000000000000000000..1a4c4b3431dd2cc4740a2e9a8a611200427f6971
--- /dev/null
+++ b/services/avatar-ui/server/src/profile_service.py
@@ -0,0 +1,176 @@
+from __future__ import annotations
+
+import json
+import logging
+import re
+from dataclasses import dataclass
+from typing import Any
+
+from google import genai
+
+from src import config
+from src.profile_store import (
+    apply_value,
+    ensure_path,
+    load_default_profile,
+    load_profile,
+    normalize_path,
+    path_exists,
+    save_profile,
+)
+
+
+logger = logging.getLogger(__name__)
+
+
+class ProfilingError(RuntimeError):
+    pass
+
+
+@dataclass(frozen=True)
+class ProfileUpdate:
+    path: list[str]
+    value: str
+    confidence: float
+    evidence: str | None = None
+
+
+@dataclass(frozen=True)
+class ProfilingStatus:
+    status: str
+    message: str | None = None
+
+
+def build_profile_prompt(transcript: str, schema: dict[str, Any]) -> str:
+    schema_overview = json.dumps(schema, ensure_ascii=False)
+    return (
+        "あなたはユーザーのプロフィール更新を支援するアシスタントです。"
+        "以下の会話からユーザーの価値観・思考傾向・言葉遣いなどを推定し、"
+        "差分更新だけを JSON で返してください。"
+        "必ず JSON のみを返し、フォーマットは次の通りです:\n"
+        "{\"updates\": ["
+        "{\"path\": [\"セクション\", \"項目\"], "
+        "\"value\": \"更新値\", \"confidence\": 0.0, "
+        "\"evidence\": \"短い根拠\"}]}\n"
+        "path は次のスキーマ内のキーに限定してください。\n"
+        f"profile_schema: {schema_overview}\n\n"
+        "会話:\n"
+        f"{transcript}"
+    )
+
+
+def _extract_response_text(response: Any) -> str:
+    text = getattr(response, "text", None)
+    if isinstance(text, str):
+        return text
+    candidates = getattr(response, "candidates", None)
+    if candidates:
+        content = getattr(candidates[0], "content", None)
+        parts = getattr(content, "parts", None) if content else None
+        if parts and hasattr(parts[0], "text"):
+            return parts[0].text
+    return ""
+
+
+def _extract_json_payload(text: str) -> dict[str, Any]:
+    match = re.search(r"\{.*\}", text, re.DOTALL)
+    if not match:
+        raise ProfilingError("Gemini response did not include JSON payload.")
+    try:
+        return json.loads(match.group(0))
+    except json.JSONDecodeError as exc:
+        raise ProfilingError(f"Failed to parse JSON payload: {exc}") from exc
+
+
+def parse_profile_updates(payload: dict[str, Any]) -> list[ProfileUpdate]:
+    raw_updates = payload.get("updates")
+    if not isinstance(raw_updates, list):
+        raise ProfilingError("updates is missing or invalid.")
+    updates: list[ProfileUpdate] = []
+    for entry in raw_updates:
+        if not isinstance(entry, dict):
+            continue
+        path = entry.get("path")
+        if not isinstance(path, list):
+            continue
+        value = str(entry.get("value") or "").strip()
+        try:
+            confidence = float(entry.get("confidence"))
+        except (TypeError, ValueError):
+            continue
+        evidence = entry.get("evidence")
+        normalized_path = normalize_path(path)
+        if not normalized_path:
+            continue
+        updates.append(
+            ProfileUpdate(
+                path=normalized_path,
+                value=value,
+                confidence=confidence,
+                evidence=str(evidence).strip() if isinstance(evidence, str) and evidence else None,
+            )
+        )
+    return updates
+
+
+def apply_profile_updates(
+    profile: dict[str, Any],
+    schema: dict[str, Any],
+    updates: list[ProfileUpdate],
+    min_confidence: float,
+) -> tuple[dict[str, Any], int]:
+    applied = 0
+    for update in updates:
+        if update.confidence < min_confidence:
+            continue
+        if not update.value:
+            continue
+        if not path_exists(schema, update.path):
+            continue
+        if not ensure_path(profile, schema, update.path):
+            continue
+        if not apply_value(profile, update.path, update.value):
+            continue
+        applied += 1
+    return profile, applied
+
+
+def update_profile_from_transcript(transcript: str) -> ProfilingStatus:
+    transcript = transcript.strip()
+    if not transcript:
+        return ProfilingStatus(status="ok")
+
+    schema = load_default_profile()
+    profile = load_profile()
+    prompt = build_profile_prompt(transcript, schema)
+
+    client = genai.Client(api_key=config.GOOGLE_API_KEY)
+    response = client.models.generate_content(
+        model=config.PROFILING_MODEL,
+        contents=prompt,
+    )
+    text = _extract_response_text(response)
+    if not text:
+        raise ProfilingError("Gemini response was empty.")
+    payload = _extract_json_payload(text)
+    updates = parse_profile_updates(payload)
+    updated_profile, applied = apply_profile_updates(
+        profile,
+        schema,
+        updates,
+        config.PROFILING_MIN_CONFIDENCE,
+    )
+    if applied > 0:
+        save_profile(updated_profile)
+    return ProfilingStatus(status="ok")
+
+
+def run_profiling(transcript: str) -> ProfilingStatus:
+    try:
+        return update_profile_from_transcript(transcript)
+    except ProfilingError as exc:
+        logger.warning("Profiling update failed: %s", exc)
+        return ProfilingStatus(status="failed", message=str(exc))
+    except Exception as exc:
+        logger.warning("Profiling update crashed: %s", exc)
+        return ProfilingStatus(status="failed", message="Profiling error")
diff --git a/services/avatar-ui/server/src/profile_store.py b/services/avatar-ui/server/src/profile_store.py
new file mode 100644
index 0000000000000000000000000000000000000000..9adbf2d39af207096c493b8dd94a78655152804b
--- /dev/null
+++ b/services/avatar-ui/server/src/profile_store.py
@@ -0,0 +1,106 @@
+from __future__ import annotations
+
+import copy
+from pathlib import Path
+from typing import Any
+
+import yaml
+
+from src import config
+
+
+PROFILE_DIR = config.ROOT_DIR / "profiling"
+PROFILE_PATH = PROFILE_DIR / "user_profile.yaml"
+PROFILE_DEFAULT_PATH = PROFILE_DIR / "user_profile.default.yaml"
+
+
+class ProfileStoreError(RuntimeError):
+    pass
+
+
+def _load_yaml(path: Path) -> dict[str, Any]:
+    if not path.exists():
+        raise ProfileStoreError(f"Profile file not found: {path}")
+    try:
+        with path.open("r", encoding="utf-8") as file:
+            data = yaml.safe_load(file) or {}
+    except Exception as exc:  # pragma: no cover - defensive
+        raise ProfileStoreError(f"Failed to load profile YAML: {path}") from exc
+    if not isinstance(data, dict):
+        raise ProfileStoreError(f"Profile YAML must be a mapping: {path}")
+    return data
+
+
+def _write_yaml(path: Path, data: dict[str, Any]) -> None:
+    try:
+        path.parent.mkdir(parents=True, exist_ok=True)
+        with path.open("w", encoding="utf-8") as file:
+            yaml.safe_dump(
+                data,
+                file,
+                allow_unicode=True,
+                sort_keys=False,
+                default_flow_style=False,
+            )
+    except Exception as exc:  # pragma: no cover - defensive
+        raise ProfileStoreError(f"Failed to write profile YAML: {path}") from exc
+
+
+def load_default_profile() -> dict[str, Any]:
+    return _load_yaml(PROFILE_DEFAULT_PATH)
+
+
+def load_profile() -> dict[str, Any]:
+    if PROFILE_PATH.exists():
+        return _load_yaml(PROFILE_PATH)
+    default_profile = load_default_profile()
+    _write_yaml(PROFILE_PATH, default_profile)
+    return copy.deepcopy(default_profile)
+
+
+def save_profile(profile: dict[str, Any]) -> None:
+    _write_yaml(PROFILE_PATH, profile)
+
+
+def normalize_path(path: list[str]) -> list[str]:
+    return [segment.strip() for segment in path if isinstance(segment, str) and segment.strip()]
+
+
+def path_exists(schema: dict[str, Any], path: list[str]) -> bool:
+    current: Any = schema
+    for segment in path:
+        if not isinstance(current, dict):
+            return False
+        if segment not in current:
+            return False
+        current = current[segment]
+    return True
+
+
+def ensure_path(profile: dict[str, Any], schema: dict[str, Any], path: list[str]) -> bool:
+    current_profile: Any = profile
+    current_schema: Any = schema
+    for segment in path[:-1]:
+        if not isinstance(current_schema, dict) or segment not in current_schema:
+            return False
+        current_schema = current_schema[segment]
+        if not isinstance(current_profile, dict):
+            return False
+        if segment not in current_profile or not isinstance(current_profile.get(segment), dict):
+            current_profile[segment] = copy.deepcopy(current_schema)
+        current_profile = current_profile[segment]
+    return True
+
+
+def apply_value(profile: dict[str, Any], path: list[str], value: str) -> bool:
+    if not path:
+        return False
+    current: Any = profile
+    for segment in path[:-1]:
+        if not isinstance(current, dict) or segment not in current:
+            return False
+        current = current[segment]
+    if not isinstance(current, dict) or path[-1] not in current:
+        return False
+    current[path[-1]] = value
+    return True
diff --git a/services/avatar-ui/server/src/routes/diary.py b/services/avatar-ui/server/src/routes/diary.py
index b9886de8fbde123aa8f0a6600fa23d7e3fcbead2..6e40888b03a3ad1df23f35cfd53ba3c812f3b69f 100644
--- a/services/avatar-ui/server/src/routes/diary.py
+++ b/services/avatar-ui/server/src/routes/diary.py
@@ -16,128 +16,138 @@ from src.diary_service import (
 
 
 router = APIRouter()
 
 
 class DiaryMessage(BaseModel):
     role: Literal["user", "assistant", "system"]
     content: str
     created_at: datetime | None = None
 
 
 class SearchSettingsModel(BaseModel):
     enabled: bool
     top_k: int = Field(ge=1, le=10)
     modes: list[str] | None = None
 
 
 class DiaryAnalysisModel(BaseModel):
     title: str
     importance_score: int = Field(ge=1, le=10)
     summary: str
     semantic_memory: str
     episodic_memory: str
 
 
+class ProfilingStatusModel(BaseModel):
+    status: Literal["ok", "failed"]
+    message: str | None = None
+
+
 class FinalizeDiaryRequest(BaseModel):
     workspace: str
     thread_id: str
     messages: list[DiaryMessage]
     search_settings: SearchSettingsModel
 
 
 class FinalizeDiaryResponse(BaseModel):
     doc_id: str
     inserted: int
     analysis: DiaryAnalysisModel
+    profiling: ProfilingStatusModel
 
 
 class SearchSettingsRequest(BaseModel):
     thread_id: str
     settings: SearchSettingsModel
 
 
 class SearchSettingsResponse(BaseModel):
     applied: bool
 
 
 class ErrorResponse(BaseModel):
     message: str
 
 
 @router.post(
     "/agui/diary/finalize",
     response_model=FinalizeDiaryResponse,
     responses={
         400: {"model": ErrorResponse},
         503: {"model": ErrorResponse},
     },
 )
 async def finalize_diary_route(request: FinalizeDiaryRequest) -> FinalizeDiaryResponse:
     if request.workspace != config.MINIRAG_WORKSPACE:
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
             detail="Invalid workspace.",
         )
     modes = (
         request.search_settings.modes
         if request.search_settings.modes is not None
         else config.MINIRAG_SEARCH_MODES_DEFAULT
     )
     settings = SearchSettings(
         enabled=request.search_settings.enabled,
         top_k=request.search_settings.top_k,
         modes=tuple(modes),
     )
     set_search_settings(request.thread_id, settings)
     try:
-        doc_id, inserted, analysis = await finalize_diary(
+        doc_id, inserted, analysis, profiling_status = await finalize_diary(
             messages=[message.model_dump() for message in request.messages],
             thread_id=request.thread_id,
             search_settings=settings,
         )
     except DiaryValidationError as exc:
         raise HTTPException(
             status_code=status.HTTP_400_BAD_REQUEST,
             detail=str(exc),
         ) from exc
     except DiaryAnalysisError as exc:
         raise HTTPException(
             status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
             detail=str(exc),
         ) from exc
 
     return FinalizeDiaryResponse(
         doc_id=doc_id,
         inserted=inserted,
         analysis=DiaryAnalysisModel(
             title=analysis.title,
             importance_score=analysis.importance_score,
             summary=analysis.summary,
             semantic_memory=analysis.semantic_memory,
             episodic_memory=analysis.episodic_memory,
         ),
+        profiling=ProfilingStatusModel(
+            status=profiling_status.status,
+            message=profiling_status.message,
+        ),
     )
 
 
 @router.post(
     "/agui/diary/search-settings",
     response_model=SearchSettingsResponse,
     responses={400: {"model": ErrorResponse}},
 )
 async def update_search_settings(request: SearchSettingsRequest) -> SearchSettingsResponse:
     modes = (
         request.settings.modes
         if request.settings.modes is not None
         else config.MINIRAG_SEARCH_MODES_DEFAULT
     )
     settings = SearchSettings(
         enabled=request.settings.enabled,
         top_k=request.settings.top_k,
         modes=tuple(modes),
     )
     set_search_settings(request.thread_id, settings)
     return SearchSettingsResponse(applied=True)
 
 
 async def search_diary(
     query: str,
diff --git a/services/avatar-ui/server/tests/test_profile_merge.py b/services/avatar-ui/server/tests/test_profile_merge.py
new file mode 100644
index 0000000000000000000000000000000000000000..31b9e3cb051cea8dc1a43a60b4306769c6762bc1
--- /dev/null
+++ b/services/avatar-ui/server/tests/test_profile_merge.py
@@ -0,0 +1,35 @@
+import copy
+
+from src.profile_service import ProfileUpdate, apply_profile_updates
+
+
+def test_apply_profile_updates_respects_confidence_and_empty_values():
+    schema = {
+        "基本情報": {"名前": {"フルネーム": ""}},
+        "性格": {"気質": {"明るい/暗い": ""}},
+    }
+    profile = copy.deepcopy(schema)
+    updates = [
+        ProfileUpdate(path=["基本情報", "名前", "フルネーム"], value="山田太郎", confidence=0.2),
+        ProfileUpdate(path=["性格", "気質", "明るい/暗い"], value="", confidence=0.9),
+        ProfileUpdate(path=["性格", "気質", "明るい/暗い"], value="明るい", confidence=0.95),
+    ]
+
+    updated, applied = apply_profile_updates(profile, schema, updates, min_confidence=0.6)
+
+    assert applied == 1
+    assert updated["基本情報"]["名前"]["フルネーム"] == ""
+    assert updated["性格"]["気質"]["明るい/暗い"] == "明るい"
+
+
+def test_apply_profile_updates_skips_invalid_paths():
+    schema = {"基本情報": {"名前": {"フルネーム": ""}}}
+    profile = copy.deepcopy(schema)
+    updates = [
+        ProfileUpdate(path=["基本情報", "名前", "ミドルネーム"], value="太郎", confidence=0.9),
+    ]
+
+    updated, applied = apply_profile_updates(profile, schema, updates, min_confidence=0.6)
+
+    assert applied == 0
+    assert updated == schema
diff --git a/services/avatar-ui/settings.default.json5 b/services/avatar-ui/settings.default.json5
index b99cff8cd820521a212254925d79b7e31f67f6c2..0f13522f270f84dbabd0745fbc8cbab8b1d11d78 100644
--- a/services/avatar-ui/settings.default.json5
+++ b/services/avatar-ui/settings.default.json5
@@ -67,27 +67,33 @@
     // ビープ音設定
     "beepFrequency": 600,
     "beepDuration": 0.05,
     "beepVolumeEnd": 0.01,
 
     // ラベル類
     "nameTags": {
       "user": "USER",
       "avatar": "ロゼ",
       "avatarFullName": "紅璃ロゼ",
     },
     "systemMessages": {
       "banner1": "SYSTEM {avatarFullName} Online",
       "banner2": "Session Standby",
     },
   },
   minirag: {
     baseUrl: "http://localhost:8165",
     workspace: "diary",
     searchEnabledDefault: true,
     topKDefault: 3,
     // 検索モードのデフォルト（最大3つまで）
     searchModesDefault: ["mini"],
     // MiniRAG API のタイムアウト（秒）
     timeoutSeconds: 300,
-  },  
+  },
+  profiling: {
+    // プロファイリング用のモデル
+    model: "gemini-2.5-flash",
+    // 反映する信頼度の最小値（0-1）
+    minConfidence: 0.6,
+  },
 }
